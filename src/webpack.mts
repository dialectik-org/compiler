//import rehypePrism from '@mapbox/rehype-prism';
//import remarkPrism from 'remark-prism'
import { remarkCodeFrame } from './codeframe.mjs'
import { CompilerOptions, ReactProjectData } from './types.mjs'
import CleanCSS from 'clean-css'
import CopyWebpackPlugin from 'copy-webpack-plugin'
import { readFileSync, copyFileSync } from 'fs';
import HtmlInlineScriptPlugin from 'html-inline-script-webpack-plugin'
import HtmlWebpackPlugin from 'html-webpack-plugin'
import { basename, join } from 'path'
import rehypeKatex from 'rehype-katex'
import rehypePrismPlus from 'rehype-prism-plus'
import rehypeSlug from 'rehype-slug';
import remarkEmbedImages from 'remark-embed-images'
import remarkFrontmatter from 'remark-frontmatter';
import remarkGfm from 'remark-gfm'
import remarkMath from 'remark-math'
import remarkMdx from 'remark-mdx'
import webpack from 'webpack';
import webpackDevServer from 'webpack-dev-server'
import { watch } from 'chokidar'
import TerserPlugin from 'terser-webpack-plugin'

import { Configuration as WebpackConfiguration } from 'webpack';
import { Configuration as WebpackDevServerConfiguration } from 'webpack-dev-server';

interface Configuration extends WebpackConfiguration {
  devServer?: WebpackDevServerConfiguration;
}

type FileMapping = {
  from: string;
  to: string;
};

/**
 * Generated by ChatGPT
 * Watches a list of source directories for changes and copies updated files to their respective destination directories.
 *
 * @param fileMappings - An array of FileMapping objects, each containing a 'from' field for the source directory and a 'to' field for the destination directory.
 *
 * Usage:
 * watchAndCopySourceFiles([
 *   {
 *     from: 'path/to/your/first/source',
 *     to: 'path/to/your/first/destination',
 *   },
 *   {
 *     from: 'path/to/your/second/source',
 *     to: 'path/to/your/second/destination',
 *   },
 *   // Add more source-destination pairs as needed
 * ]);
 */
function watchAndCopySourceFiles(fileMappings: FileMapping[]): void {
  fileMappings.forEach(({ from, to }) => {
    const watcher = watch(from, { ignoreInitial: true });

    watcher.on('all', (event : string, path : string) => {
      console.log(`File ${path} was ${event}, copying...`);
      copyFileSync(from, to);
      console.log(`Copied ${path} to ${to}`);
    });
  });
}

function getConfiguration(project : ReactProjectData, coptions : CompilerOptions, isDev : boolean) : Configuration {
  return {
    entry  : project.main,
    output: {
      filename: '[name].js',
      path: project.targetDir,
      publicPath: '/',
    },
    mode : isDev ? "development" : "production",
    devServer: isDev ? {
      static: {
        directory: project.targetDir,
      },
      onBeforeSetupMiddleware: function (devServer) {
        if (!devServer) {
          throw new Error('Webpack Dev Server is not defined!');
        }
        watchAndCopySourceFiles(project.copy);
      },
      host: 'localhost',
      watchFiles: project.styles,
      compress: true,
      port: 9000,
      open: true,
    } : undefined,
    resolve : {
      extensions: ['.tsx', '...'],
      modules: [project.dir, "node_modules"],
    },
    optimization: {
      minimize: true,
      minimizer: [
        new TerserPlugin({
          terserOptions: {
            format: {
              comments: project.license, // This line will remove the license-related comments
            },
          },
          extractComments: project.license, // This line will prevent creating a separate file for license comments
        }),
      ],
    },
    module : {
      rules: [
        {
          test: /\.(js|jsx)$/,
          exclude: /node_modules/,
          use: ["babel-loader"]
        },
        {
          test: /\.(ts|tsx)$/,
          exclude: /node_modules/,
          use: ["ts-loader"],
        },
        {
          test: /\.(css|scss)$/,
          use: ["style-loader", "css-loader"],
        },
        {
          test: /\.(jpg|jpeg|png|gif|mp3|svg)$/,
          //type: 'asset/inline',
          //type: 'asset/resource',
          use: ["file-loader"],
          //parser: {
          //  dataUrlCondition: {
          //    maxSize: 20 * 1024 // 20kb
          //  }
          //}
        },
        {
          test: /\.(md|mdx)?$/,
          use: [
            {loader: 'babel-loader', options: {}},
            {
              loader: '@mdx-js/loader',
              /** @type {import('@mdx-js/loader').Options} */
              options: {
                remarkPlugins : [remarkEmbedImages, remarkFrontmatter,remarkMdx, remarkGfm, remarkMath, remarkCodeFrame],
                rehypePlugins : [rehypeKatex, rehypeSlug, rehypePrismPlus]
              }
            }
          ]
        }
      ],
    },
    plugins : [
      new HtmlWebpackPlugin({
        filename: project.targetName,
        title: project.title,
        template: project.index,
        inject: project.inlineJs ? 'body' : 'head',
        templateParameters: {
          'hasStyle' : !project.inlineCss && project.styles.length > 0,
          'hasKatex' : project.hasKatex,
          'hasPrism' : project.hasPrism,
          'katexCss' : coptions.katexCss,
          'prismCss' : join(coptions.prismCss, project.prismStyle),
          'customCss': project.styles.length > 0 ? basename(project.styles[0]) : ''
        }
      }),
      //new webpack.DefinePlugin({ "process.env.API_URL": "\"http://localhost:8080\"" })
    ].concat(project.inlineJs ? [
      (new HtmlInlineScriptPlugin()) as unknown as HtmlWebpackPlugin
    ] : [])
    .concat(project.inlineCss && project.styles.length > 0 ? [
      {
        apply: (compiler : any) => {
          compiler.hooks.compilation.tap('InjectExternalCss', (compilation : any) => {
            HtmlWebpackPlugin.getHooks(compilation).beforeEmit.tapAsync(
              'InjectExternalCss',
              (data, cb) => {
                const cssFilePath = project.styles[0]; // Replace with the actual path to your CSS file
                const cssContent = readFileSync(cssFilePath, 'utf-8');
                const cleanCSS = new CleanCSS();
                const minifiedCSS = cleanCSS.minify(cssContent);
                const styleTag = `<style>${minifiedCSS.styles}</style>`;
                data.html = data.html.replace('</body>', `${styleTag}</body>`);
                cb(null, data);
              }
            );
          });
        },
      } as unknown as HtmlWebpackPlugin
    ] : [])
    .concat(!project.inlineCss && project.styles.length > 0 ? [
      new CopyWebpackPlugin({
        patterns: [
          { from: project.styles[0], to: basename(project.styles[0]) },
        ],
      })
    ] as unknown as HtmlWebpackPlugin : []),
    externals: {
      "react": "React",
      "react-dom": "ReactDOM",
    },
  }
}

export async function exec_webpack(project : ReactProjectData, coptions : CompilerOptions) {
  const config = getConfiguration(project, coptions, false)
  //console.log(JSON.stringify(config, null, 2))
  const compiler = webpack(config)
  await compiler.run((err, stats) => {
    if (err) {
      console.log(err.stack || err)
      return;
    }
    if (stats != undefined) {
      if (stats.hasErrors() || stats.hasWarnings()) {
        console.log(
          stats.toString({
            chunks: false, // Makes the build much quieter
            colors: true, // Shows colors in the console
          })
        );
      }
    }
    compiler.close(async (closeErr) => {
      // remove index file
      //unlinkSync(target.getMain())
      //unlinkSync(target.getIndex())
      //unlinkSync(target.getTmpWd())
    });
  });
}

export function start_webpack_dev(project : ReactProjectData, coptions : CompilerOptions) {
  const config = getConfiguration(project, coptions, true)
  console.log(JSON.stringify(config, null, 2))
  const compiler = webpack(config);
  if (config.devServer && config.devServer.port && config.devServer.host) {
    const server = new webpackDevServer(config.devServer, compiler);
    server.startCallback((err) => {
      if (err) {
        console.error(err);
        process.exit(1);
      }
      if (config.devServer)
        console.log(`Development server is running at http://${config.devServer.host}:${config.devServer.port}`);
    });
  }
}
